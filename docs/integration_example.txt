// rax25kb - Updated main.rs with Cross-Connect Support
// Integration example showing how to use the new architecture

use std::sync::Arc;
use std::process;

mod config;
mod kiss_translation;
mod crossconnect_manager;
mod logger;
mod pcap;
mod philflag;

use config::Config;
use logger::Logger;
use pcap::PcapWriter;
use crossconnect_manager::CrossConnectManager;

fn show_help(program_name: &str) {
    println!("rax25kb - AX.25 KISS Bridge with Multi-Port Cross-Connect Support\n");
    println!("Usage: {} [OPTIONS]\n", program_name);
    println!("Options:");
    println!("  -c <file>             Configuration file (default: rax25kb.cfg)");
    println!("  -q, --quiet           Quiet startup");
    println!("  -h, --help            Show this help");
    println!("  -v, --version         Show version\n");
    println!("Configuration File Format:");
    println!("  See example configuration file for detailed syntax\n");
    println!("Key Features:");
    println!("  - Multiple serial ports with independent configurations");
    println!("  - Cross-connects between serial ports and TCP sockets");
    println!("  - Serial-to-serial bridging with KISS port translation");
    println!("  - Standard KISS to Extended KISS translation");
    println!("  - Per-connection PhilFlag, raw copy, and parsing options\n");
    println!("Examples:");
    println!("  {} -c myconfig.cfg        # Use custom config", program_name);
    println!("  {} -q                     # Quiet startup with default config", program_name);
    println!("\nFor detailed documentation, see:");
    println!("  https://www.outpostpm.org/support.html");
    println!("  https://github.com/ke4ahr/rax25kb");
}

fn show_version() {
    println!("rax25kb version 2.0.0");
    println!("Multi-port cross-connect edition");
    println!("Copyright (C) 2025 rax25kb contributors");
    println!("License: GPL-3.0-or-later");
}

fn display_configuration(config: &Config) {
    println!("rax25kb - AX.25 KISS Bridge");
    println!("============================\n");
    
    println!("Serial Ports Configured: {}", config.serial_ports.len());
    for (id, port_config) in &config.serial_ports {
        println!("  Port {}: {}", id, port_config.device);
        println!("    Baud: {}, Flow: {:?}, Format: 8{}{}", 
            port_config.baud_rate,
            port_config.flow_control,
            match port_config.parity {
                config::Parity::None => "N",
                config::Parity::Odd => "O",
                config::Parity::Even => "E",
            },
            match port_config.stop_bits {
                config::StopBits::One => "1",
                config::StopBits::Two => "2",
            }
        );
        println!("    Extended KISS: {}", port_config.extended_kiss);
    }
    
    println!("\nCross-Connects Configured: {}", config.cross_connects.len());
    for cc in &config.cross_connects {
        println!("  Cross-Connect {}:", cc.id);
        println!("    Endpoint A: {:?}", cc.endpoint_a);
        println!("    Endpoint B: {:?}", cc.endpoint_b);
        if cc.phil_flag {
            println!("    PhilFlag: ENABLED");
        }
        if cc.parse_kiss {
            println!("    KISS Parsing: ENABLED");
        }
        if cc.raw_copy {
            println!("    Raw Copy Mode: ENABLED");
        }
    }
    
    println!("\nGlobal Settings:");
    println!("  Log Level: {}", config.log_level);
    if let Some(ref logfile) = config.logfile {
        println!("  Log File: {}", logfile);
    }
    if let Some(ref pidfile) = config.pidfile {
        println!("  PID File: {}", pidfile);
    }
    if let Some(ref pcap) = config.pcap_file {
        println!("  PCAP File: {}", pcap);
    }
    println!();
}

fn write_pidfile(path: &str) -> Result<(), Box<dyn std::error::Error>> {
    use std::fs::File;
    use std::io::Write;
    let mut file = File::create(path)?;
    writeln!(file, "{}", process::id())?;
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup signal handler for graceful shutdown
    let running = Arc::new(std::sync::atomic::AtomicBool::new(true));
    let r = running.clone();
    
    ctrlc::set_handler(move || {
        println!("\nReceived SIGINT, shutting down gracefully...");
        r.store(false, std::sync::atomic::Ordering::SeqCst);
        process::exit(0);
    })?;
    
    // Parse command-line arguments
    let args: Vec<String> = std::env::args().collect();
    
    if args.iter().any(|arg| arg == "-h" || arg == "--help") {
        show_help(&args[0]);
        return Ok(());
    }
    
    if args.iter().any(|arg| arg == "-v" || arg == "--version") {
        show_version();
        return Ok(());
    }
    
    let quiet = args.iter().any(|arg| arg == "-q" || arg == "--quiet");
    
    let config_file = args.iter()
        .position(|arg| arg == "-c")
        .and_then(|i| args.get(i + 1))
        .map(|s| s.as_str())
        .unwrap_or("rax25kb.cfg");
    
    // Load configuration
    let config = match Config::from_file(config_file) {
        Ok(cfg) => cfg,
        Err(e) => {
            eprintln!("Error loading configuration from '{}': {}", config_file, e);
            eprintln!("Use -h for help or check your configuration file syntax.");
            process::exit(1);
        }
    };
    
    // Display configuration if not quiet
    if !quiet && !config.quiet_startup {
        display_configuration(&config);
    }
    
    // Write PID file if specified
    if let Some(ref pidfile) = config.pidfile {
        if let Err(e) = write_pidfile(pidfile) {
            eprintln!("Warning: Failed to write PID file '{}': {}", pidfile, e);
        } else if !quiet {
            println!("PID {} written to {}", process::id(), pidfile);
        }
    }
    
    // Initialize logger
    let logger = Arc::new(Logger::new(
        config.logfile.clone(),
        config.log_level,
        config.log_to_console,
    )?);
    
    logger.log("rax25kb starting - multi-port cross-connect mode", 5);
    
    // Initialize PCAP writer if specified
    let pcap_writer = if let Some(ref pcap_path) = config.pcap_file {
        match PcapWriter::new(pcap_path) {
            Ok(writer) => {
                logger.log(&format!("PCAP capture enabled: {}", pcap_path), 5);
                Some(Arc::new(writer))
            }
            Err(e) => {
                logger.log(&format!("Warning: Failed to create PCAP file: {}", e), 4);
                None
            }
        }
    } else {
        None
    };
    
    // Validate configuration
    if config.serial_ports.is_empty() {
        eprintln!("Error: No serial ports configured");
        eprintln!("Add at least one serial_portXXXX entry to your configuration file");
        process::exit(1);
    }
    
    if config.cross_connects.is_empty() {
        eprintln!("Error: No cross-connects configured");
        eprintln!("Add at least one cross_connectXXXX entry to your configuration file");
        process::exit(1);
    }
    
    // Create and start cross-connect manager
    logger.log("Initializing cross-connect manager", 5);
    
    let mut manager = match CrossConnectManager::new(config, logger.clone(), pcap_writer) {
        Ok(mgr) => mgr,
        Err(e) => {
            eprintln!("Error initializing cross-connect manager: {}", e);
            logger.log(&format!("Fatal error: {}", e), 0);
            process::exit(1);
        }
    };
    
    // Start all cross-connects
    logger.log("Starting all cross-connects", 5);
    
    if let Err(e) = manager.start_all() {
        eprintln!("Error starting cross-connects: {}", e);
        logger.log(&format!("Fatal error: {}", e), 0);
        process::exit(1);
    }
    
    logger.log("All cross-connects started successfully", 5);
    
    if !quiet {
        println!("rax25kb is running. Press Ctrl+C to stop.");
    }
    
    // Run forever (or until SIGINT)
    manager.run_forever();
    
    Ok(())
}

// ==============================================================================
// USAGE EXAMPLES
// ==============================================================================

/*

EXAMPLE 1: Simple single TNC configuration
-------------------------------------------
Configuration file (simple.cfg):

serial_port0000=/dev/ttyUSB0
serial_port0000_baud=9600
cross_connect0000=serial:0000:0 <-> tcp:0.0.0.0:8001
log_level=5

Run:
  rax25kb -c simple.cfg


EXAMPLE 2: Dual TNC with digipeater bridging
---------------------------------------------
Configuration file (digipeater.cfg):

serial_port0000=/dev/ttyUSB0
serial_port0000_baud=9600
serial_port0001=/dev/ttyUSB1
serial_port0001_baud=9600

# Bridge TNCs together
cross_connect0000=serial:0000:0 <-> serial:0001:0
cross_connect0000_parse_kiss=true

# Provide external access
cross_connect0001=serial:0000:0 <-> tcp:0.0.0.0:8001

log_level=6

Run:
  rax25kb -c digipeater.cfg


EXAMPLE 3: KISS to Extended KISS translation
---------------------------------------------
Configuration file (translation.cfg):

# Standard KISS TNC
serial_port0000=/dev/ttyUSB0
serial_port0000_baud=9600
serial_port0000_extended_kiss=false

# Extended KISS TNC
serial_port0001=/dev/ttyUSB1
serial_port0001_baud=9600
serial_port0001_extended_kiss=true

# Translate between them
cross_connect0000=serial:0000:0 <-> serial:0001:3
cross_connect0000_parse_kiss=true

log_level=6
logfile=/var/log/rax25kb.log

Run:
  rax25kb -c translation.cfg


EXAMPLE 4: Multi-application single TNC
----------------------------------------
Configuration file (multi-app.cfg):

serial_port0000=/dev/ttyUSB0
serial_port0000_baud=9600

# APRS on KISS port 0
cross_connect0000=serial:0000:0 <-> tcp:0.0.0.0:8001

# Messaging on KISS port 1
cross_connect0001=serial:0000:1 <-> tcp:0.0.0.0:8002

# Telemetry on KISS port 2
cross_connect0002=serial:0000:2 <-> tcp:0.0.0.0:8003

# Configuration/raw access on KISS port 3
cross_connect0003=serial:0000:3 <-> tcp:127.0.0.1:8004
cross_connect0003_raw_copy=true

log_level=5

Run:
  rax25kb -c multi-app.cfg


EXAMPLE 5: Windows configuration
---------------------------------
Configuration file (windows.cfg):

serial_port0000=COM3
serial_port0000_baud=9600
serial_port0001=COM4
serial_port0001_baud=115200
serial_port0001_flow_control=hardware

cross_connect0000=serial:0000:0 <-> tcp:127.0.0.1:8001
cross_connect0001=serial:0001:0 <-> tcp:0.0.0.0:8002
cross_connect0001_phil_flag=true

log_level=6
logfile=C:\ProgramData\rax25kb\rax25kb.log
pidfile=C:\ProgramData\rax25kb\rax25kb.pid

Run:
  rax25kb.exe -c windows.cfg


EXAMPLE 6: Complex multi-TNC setup
-----------------------------------
Configuration file (complex.cfg):

# Three TNCs
serial_port0000=/dev/ttyUSB0  # VHF APRS
serial_port0000_baud=9600
serial_port0001=/dev/ttyUSB1  # UHF Messaging
serial_port0001_baud=9600
serial_port0002=/dev/ttyUSB2  # HF Packet
serial_port0002_baud=1200

# VHF APRS - external access
cross_connect0000=serial:0000:0 <-> tcp:0.0.0.0:8001
cross_connect0000_parse_kiss=true

# UHF Messaging - localhost only
cross_connect0001=serial:0001:0 <-> tcp:127.0.0.1:8002
cross_connect0001_parse_kiss=true

# HF Packet - localhost only
cross_connect0002=serial:0002:0 <-> tcp:127.0.0.1:8003

# Bridge VHF and UHF together for relay
cross_connect0003=serial:0000:1 <-> serial:0001:1
cross_connect0003_parse_kiss=true

log_level=6
logfile=/var/log/rax25kb.log
pcap_file=/var/log/rax25kb.pcap

Run:
  rax25kb -c complex.cfg

*/